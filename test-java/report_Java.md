## Решения

> Условие: 
> 30_000_000 записей всего
> 18_758_328 уникальных номеров телефонов
> ~ 20 длина полного имени

Пусть оперативная память ничем не ограничена. (В условии не указано). Для примеров будем использовать Java 8.

### Решение задачи 1)

Чтобы поиск выполнялся со сложностью в среднем ~ О(1) необходимо использовать структуру данных - хеш-таблица (метод перемешивания или сцепления). Желательно будет оптимизировать хеш - функцию, чтобы она потребляла меньше ресурсов и возникало как можно меньше коллизий и сохранять ее значения вместе с ключом + не будем сильно задумывать можно ли будет. 

Будем хранить все записи в таблице и использовать в качестве ключа - значение хеш функции, а в качестве значения - запись о пользователе. 

Не будем хранить повторные записи (запись будет создавать коллизию поскольку будет браться хеш от такого же номера телефона).

В Java хеш таблица представлена как HashMap.

Тогда нам потребуется вот столько памяти на полную запись:
1. В одной элементе будем использовать две строки типа (String). Заголовок в String занимает - 8 байт
2. Длина массива (int) -  4 байта
3. Ссылка на char[] (1 символ занимает 2 байта), а у нас в среднем 20 символов - 40 байт
4. Суммарно на одно полное имя - 8 + 4 + 40 = 52 байта

Хеш можно хранить как int и одни хеш будет занимать 4 байта

Суммарно одна запись будет занимать 56 байт, таких записей будет 18_758_328 * 56 = 1050_466_368 байт памяти для хранения нашей базы.

PS Плюс еще различный системные элементы, которые требует сам язык/платформа и его структуры.

--- 

### Решение задачи 2)

Мысль №1 - если хотим сэкономить на памяти, должны быть тяжелые вычисления или вероятностные алгоритмы.

Лобовое решение: можно взять линейный список, который будет хранить только ссылку на следующий элемент и массив char. Это будет стоить






